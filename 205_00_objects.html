<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html><head>
<title>Di più sugli object</title>
<link href="style.css" rel="stylesheet" type="text/css">
</head>
<body background="images/back.gif">
<!--START-->


<h1>Di più sugli object</h1>

Quando crei un object in Advanced Mode, puoi cambiare qualche
opzione avanzata addizionale.

<h3>Depth (profondità)</h3>

Per prima cosa, puoi impostare la <b>Depth</b> (profondità) delle istanze dell' object.
Quando le istanze sono disegnate sullo schermo sono disegnate secondo la loro depth.
Le istanze con depth maggiore sono disegnate per prime (quindi stanno dietro). Le istanze con la
depth minore sono disegnate per ultime (quindi stanno davanti). quando delle istanze hanno uguale
depth, si segue l'ordine secondo cui sono state create. Se vuoi essere sicuro che
un object stia davanti agli altri, dagli una depth negativa. Se vuoi
essere sicuro che stia dietro alle altre istanze, dagli una depth grande e positiva.
Puoi anche cambiare la depth di un'istanza durante il gioco usando la
variabile chiamata "depth".

<h3>Object persistenti (persistent)</h3>


In secondo luogo, puoi far diventare un object persistente (persistent). Un object persistente
continuerà a esistere quando ti sposti da una room a un'altra.
Scompare solo se lo distruggi esplicitamente. Devi solo mettere
un'istanza di quell'object nella prima room e poi rimarrà disponibile
in tutte le room. È molto utile quando, per esempio, hai un personaggio principale che si muove
da una room all'altra. L'uso object persistenti è un meccanismo potente ma
può portare facilmente a errori.

<h3>Parents (Object "genitori" e "figli")</h3>

Ogni object può avere un object che è il suo parent ("genitore"). Quando un object ha un parent,
eredita il comportamento del parent. Detto diversamente, l'object è una specie
di caso speciale del suo parent. Per esempio, se hai 4 diverse
palle, chiamate ball1, ball2, ball3 e ball4, che si comportano tutte allo stesso modo ma
hanno diversi sprite, puoi impostare ball1 come parent degli altri tre.
Ora devi solo specificare gli eventi per ball1. Gli altri erediteranno gli
event e si comporteranno esattamente allo stesso modo. Inoltre, quando ti riferisci alle
istanze di un object che è parent, ti riferisci contemporaneamente anche ai "figli".
Quindi, per esempio, se distruggi tutte le istanze di ball1, anche le istanze di
ball2, ball3 e ball4 verranno distrutte. Questo ti fa risparmiare un bel po' di lavoro.

<p>
Often, objects should behave almost identically but there will be
some small differences. For example, one monster might move up and down and
the other left and right. For the rest they have exactly the same behavior.
In this case almost all events should have the same actions but one or two
might be different. Again we can make one object the parent of the other.
But in this case we also define certain events for the child object. These
events &quot;override&quot; the parent events. So whenever an event for the
child object contains actions, these are executed instead of the event of
the parent. If you also want to execute the parent event you can call the
so-called &quot;inherited&quot; event using the appropriate action.

<p>
It is actually good practice in such cases to create one base object.
This base object contains all the default behavior
but is never used in the game. All actual objects have this base object as parent.
Parent objects can again have parents, and so on. (Obviously you are not
allowed to create cycles.) In this way you can create an object hierarchy.
This is extremely useful to keep your game structured and you are strongly
advised to learn to use this mechanism.

<p>
There is also a second use of the parent object. It also inherits the
collision behavior for other objects. Let us explain this with an example.
Assume you have four different floor objects. When a ball hits the floor it
must change direction. This has to be specified in the collision event of
the ball with the floor. Because there are four different floors we need to
put the code on four different collision events of the ball. But when you
make one base floor object and make this one the parent of the four actual
floor objects, you only need to specify the collision event with this base
floor. The other collisions will perform the same event. Again, this saves a
lot of copying.

<p>
As indicated, wherever you use an object, this also implies the descendants.
This happens when, in an action, you indicate that the action must be
applied to instances of a certain object. It also happens when you use the
<tt>with()</tt> statement in code (see below). And it works when you call
functions like <tt>instance_position</tt>, <tt>instance_number</tt>, etc.
Finally, it works when you refer to variables in other objects. In the
example above when you set <tt>ball1</tt>.speed to 10 this also applies to
ball2, ball3 and ball4.

<h3>Masks</h3>

When two instances collide a collision event occurs. To decide whether two
instances intersect, the sprites are used. This is fine in most cases, but
sometimes you want to base collisions on a different shape. For example, if
you make an isometric game, objects typically have a height (to give them a
3D view). But for collisions you only want to use the ground part of the
sprite. This can be achieved by creating a separate sprite that is used as
collision mask for the object.

<h3>Information</h3>

The button <b>Show Information</b> gives an overview of all information for
the object that can also be printed. This is particularly useful when you
loose overview of all your actions and events.

<!--END-->
</body>
</html>

<!-- KEYWORDS
depth
persistent objects
persistence, objects
parent object
inheritance
masks
object information
--> 
